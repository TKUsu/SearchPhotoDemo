//
//  Router.swift
//  NetworkLayer
//
//  Created by SuJustin on 2019/12/6.
//  Copyright Â© 2019 SuJustin. All rights reserved.
//

import Foundation

class Router<EndPoint: EndPointType>: NetworkRouter {
    var taskStatus: URLSessionTask.State? {
        return task?.state
    }
    
    var task: URLSessionTask?
    var group: DispatchQueue!
    var cerFileName: String!
    var timeoutInterval: Double = 10
    
    init() {
        if #available(iOS 10.0, *) {
            group = DispatchQueue(label: "CAllAPI", qos: .default, attributes: .concurrent, autoreleaseFrequency: .workItem, target: nil)
        } else {
            group = DispatchQueue(label: "CAllAPI")
        }
    }
    
    func request(_ route: EndPoint, SSLEnable: Bool = false, cerFileName: String, completion: @escaping NetworkRouterCompletion) {
        group.async {
            self.cerFileName = cerFileName
            let session = self.setupSSL(enable: SSLEnable)
            do {
                let request = try self.buildRequest(from: route)
                self.task = session.dataTask(with: request, completionHandler: { (data, response, error) in
                    completion(data, response, error)
                })
            } catch {
                completion(nil, nil, error)
            }
            self.task?.resume()
        }
    }
    
    func request(_ route: EndPoint, completion: @escaping NetworkRouterCompletion) {
        group.async {
            let session = self.setupSSL(enable: false)
            do {
                let request = try self.buildRequest(from: route)
                self.task = session.dataTask(with: request, completionHandler: { (data, response, error) in
                    completion(data, response, error)
                })
            } catch {
                completion(nil, nil, error)
            }
            self.task?.resume()
        }
    }
    
    func cancel() {
        self.task?.cancel()
    }
    
    // MARK: private
    private func setupSSL(enable: Bool) -> URLSession {
        let session: URLSession!
        if !enable{
            session = URLSession(configuration: .default)
            return session
        }else{
            // SSL
            let delegate = SessionDelegate(cerResource: cerFileName)
            let configuration = URLSessionConfiguration.default
            configuration.networkServiceType = .responsiveData
            session = URLSession(configuration: configuration, delegate: delegate, delegateQueue: OperationQueue.current)
            return session
        }
    }
}
// MARK: Build Request (Private)
extension Router{
    // EndPointType building to request
    private func buildRequest(from route: EndPoint) throws -> URLRequest{
        
        // Create a URLRequest variable, generated by route.baseURL followed by a specific route.path
        // .reloadIgnoringLocalAndRemoteCacheData: cache isn't save.
        var request = URLRequest(
            url: route.baseURL.appendingPathComponent(route.path),
            cachePolicy: .reloadIgnoringLocalAndRemoteCacheData,
            timeoutInterval: timeoutInterval)
        
        // set url method
        request.httpMethod = route.httpMethod.rawValue
        
        // set url task
        do {
            switch route.task {
            case .request:
                request.setValue(APPLICATION_JSON, forHTTPHeaderField: CONTENTTYPE)
                break
            case .requestParameters(let bodyParameters, let urlParameters):
                try configureURL(&request, parameters: urlParameters)
                try configureBody(&request, parameters: bodyParameters)
                break
//            case .requestParameters(let bodyParameters, let urlParameters, let additionHeaders, let dataParameters):
//                addAdditionalHeaders(additionHeaders, request: &request)
//                try configureURL(&request, parameters: urlParameters)
//                if dataParameters != nil{
//                    try configureBody(&request, parameters: bodyParameters, dataParameters: dataParameters)
//                }else{
//                    try configureBody(&request, parameters: bodyParameters)
//                }
//                break
//            case .requestCodable(let bodyParameters, let urlParameters, let additionHeaders):
//                addAdditionalHeaders(additionHeaders, request: &request)
//                try configureURL(&request, parameters: urlParameters)
//                try configureBody(&request, Codable: bodyParameters)
//                break
//            case .requestString(let bodyParameters, let urlParameters, let additionHeaders):
//                addAdditionalHeaders(additionHeaders, request: &request)
//                try configureURL(&request, parameters: urlParameters)
//                try configureBody(&request, string: bodyParameters)
//                break
            }
            return request
        } catch {
            throw error
        }
    }
    
    /// header setValue
    ///
    /// - Parameters:
    ///   - additional: HTTPHeader [String: String]
    ///   - request: HTTTPRequest
    private func addAdditionalHeaders(_ additional: HTTPHeaders?, request: inout URLRequest){
        guard let headers = additional else { return }
        for (k, v) in headers{
            request.setValue(v, forHTTPHeaderField: k)
        }
    }
    
    private func configureURL(_ request: inout URLRequest, parameters: URLParameters?) throws{
        do {
            if let bodyParameters = parameters{
                try URLParameterEncoder.encode(urlRequest: &request, with: bodyParameters)
            }
        } catch {
            throw error
        }
    }
    
    /// Use `JSONParameterEncoder` _JSON
    ///
    /// - Parameters:
    ///   - bodyParameters: JSON format
    ///   - request: URLRequest
    /// - Throws: NetworkError
    private func configureBody(_ request: inout URLRequest, parameters: Parameters?) throws{
        do {
            if let bodyParameters = parameters{
                try JSONParameterEncoder.encode(urlRequest: &request, with: bodyParameters)
            }
        } catch {
            throw error
        }
    }
    /// Use `JSONParameterEncoder` _format
    ///
    /// - Parameters:
    ///   - bodyParameters: JSON format
    ///   - request: URLRequest
    /// - Throws: NetworkError
    private func configureBody(_ request: inout URLRequest, parameters: Parameters?, dataParameters: Parameters?) throws{
        do {
            if let bodyParameters = parameters{
                try JSONParameterEncoder.encode(urlRequest: &request, with: bodyParameters)
            }
        } catch {
            throw error
        }
    }
    
    /// Use `JSONParameterEncoder` _JSON
    ///
    /// - Parameters:
    ///   - bodyParameters: Encodable JSON
    ///   - urlParameters: URL format
    ///   - request: URLRequest
    /// - Throws: NetworkError
    fileprivate func configureBody(_ request: inout URLRequest, Codable Parameters: EncodableParameters?) throws{
        do {
            if let bodyParameters = Parameters{
                try JSONParameterEncoder.encode(urlRequest: &request, with: bodyParameters)
            }
        } catch {
            throw error
        }
    }
    
    /// Use `StringParameterEncoder` _String
    ///
    /// - Parameters:
    ///   - bodyParameters: String Data (Encoding: UTF-8)
    ///   - urlParameters: URL format
    ///   - request: URLRequest
    /// - Throws: NetworkError
    fileprivate func configureBody(_ request: inout URLRequest, string Parameters: StringParameters?) throws{
        do {
            if let bodyParameters = Parameters{
                try StringParameterEncoder.encode(urlRequest: &request, with: bodyParameters)
            }
        } catch {
            throw error
        }
    }
}
